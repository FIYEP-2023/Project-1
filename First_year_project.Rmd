---
title: "First_Year_Project"
output: pdf_document
date: "2023-02-07"
---

```{r setup, include=FALSE, results=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, results=FALSE, message=FALSE}
if (!require("pacman")) install.packages("pacman")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("ggpmisc")) install.packages("ggpmisc")
if (!require("ggpubr")) install.packages("ggpubr")
if (!require("ggsignif")) install.packages("ggsignif")
library("ggplot2")
library("ggpmisc")
library("ggpubr")
library("ggsignif")
library(tibble)
library(ggplot2)
library(broom)
```

# Question one

*Begin with describing and fitting a full model in which the intercepts and slopes of the extinction times versus numbers of pairs may be different in all four combinations of size and migratory status.*\
We start by importing the dataset directly from the csv file and saving it to the data variable:

```{r}
head(data <- read.csv('Factors Affecting Extinction.csv', header=T))
```

# (1) Initial Plotting

There are four different combinations of Size and Status, LR, LM, SR and SM. If we want to find the correlation between *extinction time* as a function of *pairs*, we can make a regression line with *pairs* as the predictor value and *extinction time* as the predicted value.

```{r}
ggplot(data, aes(x = Pairs, y = Time)) +
  geom_point() +
  facet_grid(Size ~ Status) +
  theme(legend.position = "top") +
  geom_smooth(method = "lm", formula = y ~ x) +
  
  stat_poly_eq(formula = y ~ x,
  aes(label = paste(after_stat(eq.label), after_stat(rr.label), sep = "~~~")),
  parse = TRUE) +
  
  labs(title = "Raw data") +
  theme_bw()
```

# (2) Residual plot of raw (not transformed) data
# This is the ONLY correct residual plot

```{r}
model <- lm(Time ~ Pairs, data = data)
y_hat <- predict(model, newdata = data)

ggplot(data,
  mapping = aes(x = y_hat,
                y = resid(lm(Time ~ Pairs, data = data)))) +
  geom_point() +
  facet_grid(Size ~ Status) +
  geom_hline(yintercept = 0, color = "red") +
  xlab("Predicted value") +
  ylab("Standarized Residuals") +
  labs(title = "Standardized Residual Plot (raw data)") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(legend.position = "bottom")
```

# (2) Transformations of time to log_time, sqrt_time, inverse_time

```{r}
data$log_time <- log2(data$Time)
data$sqrt_time <- sqrt(data$Time)
data$inverse_time <- 1/data$Time
head(data)
```
\newpage
Plotting of log_time:

```{r echo=FALSE, results=FALSE, message=FALSE}
transform_plots <- function(type, data, Y, transformation) {
  # type is one of "regres", "resid"
  data$Y = Y
  model <- lm(Time ~ Pairs, data = data)
  y_hat <- predict(model, newdata = data)
  result <- switch(
    type,
    "regres" = ggplot(
      data,
      aes(x = Pairs, y = Y)
    )
    + geom_point()
    + facet_grid(Size ~ Status) 
    + theme(legend.position = "top")
    + geom_smooth(
        method = "lm", 
        formula = y ~ x
      )
    + stat_poly_eq(
      formula = y ~ x,
      aes(
        label = paste(
          after_stat(
            eq.label
          ), 
          after_stat(
            rr.label
          ), 
          sep = "~~~"
        )
      ),
      parse = TRUE
    )
    + labs(
      title = sprintf("Raw data (%s)", transformation)
    )
    + ylab(
      sprintf("Time (%s)", transformation)
    )
    + theme_bw(),
    
    "resid" = ggplot(
      data,
      mapping = aes(
        x = y_hat,
        y = resid(
          lm(
              Y ~ Pairs, 
              data = data
            )
          )
        )
      )
    + geom_point()
    + facet_grid(Size ~ Status)
    + geom_hline(
        yintercept = 0, 
        color = "red"
      )
    + xlab("Predicted value")
    + ylab("Standarized Residuals")
    + labs(
      title = sprintf(
        "Standardized Residual Plot (raw data) (%s transformation)",
        transformation)
      )
    + theme_bw()
    + theme(plot.title = element_text(hjust = 0.5))
    + theme(legend.position = "bottom")

  )
  return(result)
}

for (transformation in c("log", "sqrt", "inverse")) {
  new_Y <- switch(
    transformation,
    "log" = log2(data$Time),
    "sqrt" = sqrt(data$Time),
    "inverse" = 1/data$Time
  )
  print(transform_plots("regres", data, new_Y, transformation))
  print(transform_plots("resid", data, new_Y, transformation))
}
```
